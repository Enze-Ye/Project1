import argparse, csv, math, random, os, time

# Load language model (unigram + bigram) for space + A..Z
def load_lm(ftable_csv):
    rows = list(csv.reader(open(ftable_csv, newline="", encoding="utf-8", errors="replace")))
    sym = rows[0][1:]
    K = len(sym)
    counts = {}
    for r in rows[1:]:
        if not r: continue
        a = (r[0] or " ").strip() or " "
        for i, cell in enumerate(r[1:]):
            try: v = float(cell)
            except: v = 0.0
            counts[(a, sym[i])] = v
    row_sum = {}
    for (a,b),v in counts.items():
        row_sum[a] = row_sum.get(a, 0.0) + v
    log_big = {}
    for (a,b),v in counts.items():
        tot = row_sum.get(a, 0.0)
        p = (v + 1.0) / (tot + K) if tot > 0 else 1.0 / K
        log_big[(a,b)] = math.log(p)
    col = {b:1.0 for b in sym}
    for (a,b),v in counts.items():
        col[b] = col.get(b, 0.0) + v
    totu = sum(col.values())
    log_uni = {b: math.log(col[b] / totu) for b in sym}
    return log_uni, log_big

# Byteâ†’scoring symbol (space/A..Z) + small penalty
def b2sym(b):
    if b == 32: return " ", 0.0
    if 65 <= b <= 90:  return chr(b), 0.0
    if 97 <= b <= 122: return chr(b - 32), 0.0
    return " ", -1.0

# Small English word bonus
def word_bonus(bs):
    common = {"THE","AND","OF","TO","IN","A","IS","THAT","IT","FOR","AS","WITH","WAS"}
    toks = bytes(bs).decode("utf-8", "ignore").upper().split()
    return 0.25 * sum(1 for t in toks if t in common)

# Objective = LM(p1)+LM(p2)+word bonuses
def total_obj(p1, X, log_uni, log_big):
    p2 = bytes(a ^ b for a, b in zip(p1, X))
    def score_seq(s):
        if not s: return -1e18
        c0,p0 = b2sym(s[0]); sc = log_uni.get(c0, -20) + p0
        for i in range(1, len(s)):
            a,pa = b2sym(s[i-1]); b,pb = b2sym(s[i])
            sc += log_big.get((a,b), -20) + pb
        return sc
    return score_seq(p1) + score_seq(p2) + word_bonus(p1) + word_bonus(p2)

# Greedy unigram init for p1
def init_p1_unigram(X, log_uni):
    k = len(X)
    p1 = bytearray(k)
    alphabet = [32] + list(range(65, 91))
    for i, xi in enumerate(X):
        best_b, best = 32, -1e18
        for b in alphabet:
            c1,_ = b2sym(b)
            c2,_ = b2sym(b ^ xi)
            sc = log_uni.get(c1, -20) + log_uni.get(c2, -20)
            if sc > best:
                best, best_b = sc, b
        p1[i] = best_b
    return p1

# If x[i] looks like letter, enforce exactly one side is space
def letter_hint(xb):
    ch,_ = b2sym(xb)
    return ch != " "

# Save best-so-far outputs safely
def save_outputs(c1, best_p1, X):
    p1 = best_p1
    p2 = bytes(a ^ b for a, b in zip(p1, X))
    pad = bytes(a ^ b for a, b in zip(c1, p1))
    with open("plain1.txt", "wb") as f: f.write(p1)
    with open("plain2.txt", "wb") as f: f.write(p2)
    with open("pad.bin",  "wb") as f: f.write(pad)

# Main search: annealed, warm restarts, hard constraints, local greedy, checkpoints, max_time
def search(c1, c2, X, log_uni, log_big, restarts, iters, save_every, max_time):
    k = len(X)
    alphabet = [32] + list(range(65, 91))
    best_p1, best_val = b"", -1e18
    start_ts = time.time()

    # resume if existing results found
    if os.path.exists("plain1.txt"):
        try:
            prev = open("plain1.txt","rb").read()
            if len(prev) == k:
                best_p1 = prev
                best_val = total_obj(prev, X, log_uni, log_big)
                print(f"[resume] loaded plain1.txt, score={best_val:.3f}")
        except Exception:
            pass

    step_since_save = 0
    for r in range(restarts):
        if max_time and time.time() - start_ts > max_time:
            print("[stop] max_time reached before new restart")
            break

        if best_p1 and random.random() < 0.5:
            p1 = bytearray(best_p1)
            J = max(1, k // 100)
            for _ in range(J):
                i = random.randrange(k)
                xi = X[i]
                if letter_hint(xi):
                    cands = [32, xi ^ 32]
                else:
                    cands = alphabet
                p1[i] = random.choice(cands)
            warm = True
        else:
            p1 = init_p1_unigram(X, log_uni)
            warm = False

        cur = total_obj(p1, X, log_uni, log_big)
        print(f"[restart {r+1}/{restarts}] start_score={cur:.3f} (warm={warm}) best_so_far={best_val:.3f}", flush=True)

        for it in range(iters):
            if max_time and time.time() - start_ts > max_time:
                print("[stop] max_time reached during iterations")
                save_outputs(c1, best_p1, X)
                return best_p1

            i = random.randrange(k)
            xi = X[i]
            if letter_hint(xi):
                cands = [32, xi ^ 32]
            else:
                cands = alphabet

            old = p1[i]
            nb  = random.choice(cands)
            if nb != old:
                p1[i] = nb
                new = total_obj(p1, X, log_uni, log_big)
                d = new - cur
                T = max(0.02, 1.0 - it / max(1, iters))
                if d >= 0 or random.random() < math.exp(d / T):
                    cur = new
                    if cur > best_val:
                        best_val = cur
                        best_p1 = bytes(p1)
                else:
                    p1[i] = old

            if (it + 1) % 20000 == 0:
                j = random.randrange(k)
                xj = X[j]
                cands = [32, xj ^ 32] if letter_hint(xj) else alphabet
                best_bj, best_loc = p1[j], cur
                for bj in cands:
                    old_bj = p1[j]
                    p1[j] = bj
                    sc = total_obj(p1, X, log_uni, log_big)
                    if sc > best_loc:
                        best_loc, best_bj = sc, bj
                    p1[j] = old_bj
                if best_bj != p1[j]:
                    p1[j] = best_bj
                    cur = best_loc
                    if cur > best_val:
                        best_val = cur
                        best_p1 = bytes(p1)

            step_since_save += 1
            if save_every and step_since_save >= save_every and best_p1:
                save_outputs(c1, best_p1, X)
                step_since_save = 0

            if (it + 1) % 10000 == 0:
                print(f"[restart {r+1}] iter={it+1}/{iters} score={cur:.3f} global_best={best_val:.3f}", flush=True)

        print(f"[restart {r+1}] end_score={cur:.3f} global_best={best_val:.3f}", flush=True)
        if best_p1:
            save_outputs(c1, best_p1, X)

    if best_p1:
        save_outputs(c1, best_p1, X)
    return best_p1

# CLI
def main():
    ap = argparse.ArgumentParser(description="Two-time-pad English solver with checkpoints (long-run).")
    ap.add_argument("ct_bin")
    ap.add_argument("ftable_csv")
    ap.add_argument("--k", type=int, default=1024)
    ap.add_argument("--restarts", type=int, default=12)
    ap.add_argument("--iters", type=int, default=5000000)
    ap.add_argument("--seed", type=int, default=1)
    ap.add_argument("--save_every", type=int, default=20000)
    ap.add_argument("--max_time", type=int, default=0)  # seconds, 0=unlimited
    args = ap.parse_args()

    if args.seed:
        random.seed(args.seed)

    data = open(args.ct_bin, "rb").read()
    if len(data) != 2 * args.k:
        raise SystemExit(f"expected {2*args.k} bytes, got {len(data)}")
    c1, c2 = data[:args.k], data[args.k:]
    X = bytes(a ^ b for a, b in zip(c1, c2))

    log_uni, log_big = load_lm(args.ftable_csv)
    best_p1 = search(c1, c2, X, log_uni, log_big,
                     restarts=args.restarts, iters=args.iters,
                     save_every=args.save_every, max_time=args.max_time)

    if best_p1:
        print("[+] wrote plain1.txt, plain2.txt, pad.bin")
    else:
        print("[!] no solution saved (try larger iters/restarts or different seed)")

if __name__ == "__main__":
    main()
