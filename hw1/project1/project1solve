#!/usr/bin/env python3
# Usage:
#   /project/web-classes/Fall-2025/csci5471/second2tp > ct2.bin
#   python3 spacevote_solver.py ct2.bin /project/web-classes/Fall-2025/csci5471/hw1/ftable2.csv --passes 4 --win 14 --thr 1.2

import argparse, csv, math, collections

# Load language model (unigram + bigram) for symbols: space and A..Z
def load_lm(ftable_csv):
    rows = list(csv.reader(open(ftable_csv, newline="", encoding="utf-8", errors="replace")))
    sym = rows[0][1:]
    K = len(sym)
    counts = {}
    for r in rows[1:]:
        if not r: 
            continue
        a = (r[0] or " ").strip() or " "
        for i, cell in enumerate(r[1:]):
            try:
                v = float(cell)
            except:
                v = 0.0
            counts[(a, sym[i])] = v
    row_sum = collections.Counter()
    for (a,b),v in counts.items():
        row_sum[a] += v
    log_big = {}
    for (a,b),v in counts.items():
        tot = row_sum[a]
        p = (v + 1.0) / (tot + K) if tot > 0 else 1.0 / K
        log_big[(a,b)] = math.log(p)
    col = {b: 1.0 for b in sym}
    for (a,b),v in counts.items():
        col[b] += v
    totu = sum(col.values())
    log_uni = {b: math.log(col[b] / totu) for b in sym}
    return log_uni, log_big

# Convert a byte to scoring symbol (space/A..Z) and a small penalty
def b2sym(b):
    if b == 32: return " ", 0.0
    if 65 <= b <= 90:  return chr(b), 0.0
    if 97 <= b <= 122: return chr(b - 32), 0.0
    return " ", -0.6

# Check if a byte is an ASCII letter (A..Z or a..z)
def is_alpha(b):
    return (65 <= b <= 90) or (97 <= b <= 122)

# XOR two byte strings
def bxor(a, b):
    return bytes([x ^ y for x, y in zip(a, b)])

# Score a short window using the language model
def score_slice(bs, log_uni, log_big):
    n = len(bs)
    if n == 0:
        return -1e9
    c0, p0 = b2sym(bs[0])
    s = log_uni.get(c0, -20) + p0
    for i in range(1, n):
        a, pa = b2sym(bs[i-1])
        c, pc = b2sym(bs[i])
        s += log_big.get((a, c), -20) + pc
    return s

# Recover most key bytes by space/letter voting on x=c1^c2 with LM windows
def recover_pad_spacevote(c1, c2, log_uni, log_big, win=12, passes=3, thr=2.0):
    k = len(c1)
    x = bxor(c1, c2)
    pad = [None] * k
    voteA = [0.0] * k
    voteB = [0.0] * k

    for _ in range(passes):
        for i in range(k):
            if not is_alpha(x[i]):
                continue
            a = c1[i] ^ 0x20
            b = c2[i] ^ 0x20
            L = max(0, i - win)
            R = min(k, i + win + 1)

            wpad = pad[:]
            wpad[i] = a
            p1 = bytes(c1[j] ^ (wpad[j] if wpad[j] is not None else 0) for j in range(L, R))
            p2 = bytes(c2[j] ^ (wpad[j] if wpad[j] is not None else 0) for j in range(L, R))
            sA = score_slice(p1, log_uni, log_big) + score_slice(p2, log_uni, log_big)

            wpad = pad[:]
            wpad[i] = b
            p1 = bytes(c1[j] ^ (wpad[j] if wpad[j] is not None else 0) for j in range(L, R))
            p2 = bytes(c2[j] ^ (wpad[j] if wpad[j] is not None else 0) for j in range(L, R))
            sB = score_slice(p1, log_uni, log_big) + score_slice(p2, log_uni, log_big)

            voteA[i] += sA
            voteB[i] += sB

        for i in range(k):
            if not is_alpha(x[i]):
                continue
            if voteA[i] - voteB[i] > thr:
                pad[i] = c1[i] ^ 0x20
            elif voteB[i] - voteA[i] > thr:
                pad[i] = c2[i] ^ 0x20

    for i in range(1, k - 1):
        if pad[i] is None and pad[i-1] is not None and pad[i+1] is not None and pad[i-1] == pad[i+1]:
            pad[i] = pad[i-1]

    for i in range(k):
        if pad[i] is None and is_alpha(x[i]):
            pad[i] = (c1[i] ^ 0x20) if voteA[i] >= voteB[i] else (c2[i] ^ 0x20)

    for i in range(k):
        if pad[i] is None:
            pad[i] = 0

    return bytes(pad)

# Fill remaining unknown key bytes by local LM search
def patch_holes(c1, c2, pad, log_uni, log_big, iters=2, win=8):
    k = len(c1)
    pad = bytearray(pad)
    alphabet = [32] + list(range(65, 91))
    for _ in range(iters):
        for i in range(k):
            if pad[i] != 0:
                continue
            best = pad[i]
            bests = -1e18
            L = max(0, i - win)
            R = min(k, i + win + 1)
            for guess in alphabet:
                pad[i] = guess
                p1 = bytes(c1[j] ^ pad[j] for j in range(L, R))
                p2 = bytes(c2[j] ^ pad[j] for j in range(L, R))
                s = score_slice(p1, log_uni, log_big) + score_slice(p2, log_uni, log_big)
                if s > bests:
                    bests = s
                    best = guess
            pad[i] = best
    return bytes(pad)

# CLI: read inputs, recover key, output plaintexts and pad
def main():
    ap = argparse.ArgumentParser(description="Two-time-pad solver via space voting and LM windows.")
    ap.add_argument("ct_bin")
    ap.add_argument("ftable_csv")
    ap.add_argument("--k", type=int, default=1024)
    ap.add_argument("--passes", type=int, default=4)
    ap.add_argument("--win", type=int, default=14)
    ap.add_argument("--thr", type=float, default=1.2)
    args = ap.parse_args()

    data = open(args.ct_bin, "rb").read()
    if len(data) != 2 * args.k:
        raise SystemExit(f"expected {2*args.k} bytes, got {len(data)}")
    c1, c2 = data[:args.k], data[args.k:]

    log_uni, log_big = load_lm(args.ftable_csv)
    pad = recover_pad_spacevote(c1, c2, log_uni, log_big, win=args.win, passes=args.passes, thr=args.thr)
    pad = patch_holes(c1, c2, pad, log_uni, log_big, iters=2, win=8)

    p1 = bytes(a ^ b for a, b in zip(c1, pad))
    p2 = bytes(a ^ b for a, b in zip(c2, pad))

    open("plain1.txt", "wb").write(p1)
    open("plain2.txt", "wb").write(p2)
    open("pad.bin", "wb").write(pad)
    print("[+] Wrote plain1.txt, plain2.txt, pad.bin")

if __name__ == "__main__":
    main()
